= 2024년 3분기 07월-09월 LWIL(Last week I learnt) 모음
// Metadata:
:description: Last Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font

[[section-202407]]
== 2024년 07월

[[section-202407-W1]]
=== 2024년 07월 1주
- gon: LangChain

+
LangChain은 대규모 언어 모델(LLM)을 기반으로 애플리케이션을 구축하는 오픈 소스 프레임워크입니다. LLM은 대량의 데이터로 사전 훈련된 딥 러닝 모델로, 사용자 쿼리에 응답을 생성할 수 있습니다. LangChain은 이러한 모델의 응답을 맞춤화하고 정확성을 높이는 도구와 추상화를 제공합니다. 이를 통해 개발자는 프롬프트 체인을 만들거나 템플릿을 맞춤화하고, 모델을 재훈련 없이 새 데이터에 접근할 수 있도록 할 수 있습니다.

+
LangChain의 중요성:
LLM은 일반적인 쿼리에는 잘 대응하지만, 특정 분야에서는 성능이 떨어집니다. LangChain은 내부 데이터 소스와 통합하고 프롬프트 엔지니어링을 통해 이러한 문제를 해결합니다. 이를 통해 데이터 사이언티스트는 입력을 구체화하여 생성 모델의 응답을 개선할 수 있습니다.

+
--
LangChain의 이점:

. 언어 모델 용도 변경: 재훈련 없이 LLM을 다양한 분야에 맞게 사용할 수 있습니다.
. AI 개발 간소화: 데이터 소스 통합과 프롬프트 세분화를 통해 AI 개발을 단순화합니다.
. 개발자 지원: 오픈 소스 커뮤니티의 지원을 받아 개발 시간을 단축할 수 있습니다.
--

+
--
LangChain의 핵심 구성 요소:

. LLM 인터페이스: 다양한 모델과 상호작용할 수 있는 API를 제공합니다.
. 프롬프트 템플릿: 일관된 쿼리 형식을 제공하는 사전 구축된 구조입니다.
. 에이전트: 복잡한 애플리케이션을 위해 최적의 시퀀스를 결정하는 체인입니다.
. 검색 모듈: RAG 시스템을 설계할 수 있는 도구를 제공합니다.
. 메모리: 과거 상호작용을 기억하여 응답을 개선합니다.
. 콜백: 특정 이벤트를 로깅, 모니터링 및 스트리밍할 수 있는 코드입니다.
--

+
출처 : https://aws.amazon.com/ko/what-is/langchain/

- hwan: link:https://html2canvas.hertzen.com/[html2canvas] - HTML Document 를 통째로 capture 해서 Canvas 의 image 로 만들어 주는 프로젝트. 어떻게 구현한건지 신기해서 조금 뜯어봤더니, 그냥 DOM 을 통째로 순회하며 CSS 에 맞춰 Canvas 에 그려주도록 되어 있다. 제작자의 근성에 박수를.

- wongue: link:https://en.wikipedia.org/wiki/Signed_distance_function[SDF] Signed Distance Function(or Field)는 그래픽스에서 다양한 방식으로 이용할 수 있다. +
SDF는 정의역을 실수 xy 평면 영역을 가지기 때문에, rasterzied 이미지의 SDF 를 구할 수 있다면, 이를 활용해 자유롭게 해당 이미지를 확대 축소시켜 화면에 투영 할 수 있기 때문. + 
흥미로운 그래픽 아웃풋의 예시로는 link:https://tympanus.net/codrops/2024/06/12/shape-lens-blur-effect-with-sdfs-and-webgl/[링크] 이런 예시가 있고, +
엔지니어링적으로는 link:https://www.redblobgames.com/x/2403-distance-field-fonts/[다음]과 같이 레스터 폰트 파일의 확대, 축소에 활용 될 수 있다.

[[section-202407-W2]]
=== 2024년 07월 2주
- gon: 1:N 관계의 테이블을 대용량으로 조회할 때 주의할 점
+
물론 한꺼번에 많은 데이터를 가져오지 않고, 한번에 읽을 수 있는 크기를 정해서 잘라서 가져오는 것이 많은 경우에 해답이 되지만, 
그럼에도 불구하고 한번에 많은 양의 데이터를 가져오고 싶을 때 주의할 점을 이야기합니다.
+
1:N 관계를 조회할 때 (테이블의 모든 컬럼을 조회한다고 가정할 경우), 결과의 개수는 N의 합만큼 응답됩니다. 
인덱스가 잘 걸렸는지 여부와 관계없이 N 쪽에 의해 결과가 굉장히 커질 수 있다는 것을 항상 주의하며 쿼리해야 합니다.
+
예를 들어, A 테이블과 B 테이블이 있고, 관계는 A : B = 1:4~5 정도라 하겠습니다.
+
[source, sql]
----
SELECT *
FROM A
JOIN B ON A.id = B.aId;
----
+
위 쿼리를 실행시킨다고 가정하면, 만약 A에서 5000행이 조회된다면 B는 45000행이 조회에 걸리고, 
결과적으로 응답은 45000행으로 오게 됩니다. 이럴 경우 예상보다 데이터가 커지기 때문에 인덱스를 잘 건다고 해도 느려질 수 있다. 
+
> 특히 쿼리의 실행중에 join 연산 과정이나 중간 결과를 저장하기위해 B(N)의 데이터에 A(1)의 데이터를 복사하여 메모리에 저장하는데 이 과정에서 memory copy가 일어난다. memory copy가 기본적으로 cpu보다는 느린 작업이라 자주 발생하면 굉장한 성능 저하가 올 수 있다.
+
따라서 다시 한 번 강조하지만, 쿼리의 크기를 조절해서 가져오는 것이 여러모로 좋은 방법이다.

- hwan: HTTP GET method 는 Body 를 보낼 수 없는 요청이(었)다. 그러나 RFC2616 -> RFC7230-7237 (2014년) 로 개정되며 이제는 HTTP GET 에도 Body 를 보낼 수 있고, 서버가 처리할 수도 있어야 한다.
