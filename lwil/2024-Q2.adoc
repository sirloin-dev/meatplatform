= 2024년 2분기 04월-06월 LWIL(Last week I learnt) 모음
// Metadata:
:description: Last Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font

[[section-202404]]
== 2024년 04월

[[section-202404-W1]]
=== 2024년 04월 1주
- hwan: Kotlin 에서는 extension function 도 상속을 이용한 확장 구현이 된다. Template pattern 에서 유용하게 활용할 수 있는 테크닉인듯...
+

[source, kotlin]
----
abstract class Converter<T, U> {
    protected abstract fun T.convert(): U
}

class StringToNumberConverter : Converter<String, Number> {
    override fun String.convert(): Number {
        // ..
    }
}

class StringToUuidConverter : Converter<String, Uuid> {
    override fun String.convert(): Uuid {
        // ..
    }
}
----

- gon :
+

[source, kotlin]
----
@Transactional
@Schedule(3)
fun scheduleTask() {
    if(list.isEmpty()) { return }
    // doSomething
}
----
+

위 코드를 보시면 어떤 문제가 있을것으로 생각되나요? +
@Transactional을 너무 습관적으로 붙힌 안좋은 대표적인 예라고 생각합니다. +
위 코드의 경우 task가 어떠한 일을 하지않아도 3초마다 트랜잭션을 열고 닫습니다. +
그것이 스케줄링에서 원하는 행동이라면 상관없지만 보통은 스케줄링돌때 아무일도 안하는 경우에 트랜잭션을 열 이유는 없기때문에 +
@Transactional을 사용한다면 꼭 그뒤의 동작을 잘 예상하면서 사용해야 한다.

- gyeongtae: 어제 AI engineer랑 Front 앞으로의 미래에 대해서 얘기를 나눴다. 요즘 AI를 활용한 UI 개발이 아주 빨라지고 있는데 과연 앞으로도 React가 쓰일까? HTML + CSS + jquery 같은 단순한 형태로 가도 되지 않을까란 얘기가 주였다. 삼신기라고 하면서 설명을 했는데 비슷한 생각을 나 또한 하고 있다. 앞으로 FE의 미래가 궁금해지긴 한다. 관련 자료들을 찾아보면 좋을거같다.

[[section-202404-W2]]
=== 2024년 04월 2주
- hwan: MacOS 에서 Android Build 를 하면 환경변수로 설정한 JAVA_HOME 을 무시하고 /Applications/Android Studio.app/Contents/jre/Contents/Home 를 강제로 JAVA_HOME 으로 설정해 버린다. 이 때문에 Android Studio 의 JDK 보다 높은 버전의 라이브러리를 이용할 경우 JDK Version 이 맞지 않는 문제가 발생한다. Android Studio 를 삭제해서 당장 문제를 해결하긴 했지만 근본적인 해결책이 무엇일까...

- gon : 
클라이언트가 서버로부터 실시간으로 정보를 받기위한 방법

폴링(Polling) +
- **특징**: 클라이언트가 정기적으로 서버에 HTTP 요청을 보내어 최신 정보를 요청하는 방식입니다. +
- **장점**: 구현이 간단하고 모든 웹 환경에서 사용할 수 있습니다. +
- **단점**: HTTP 요청과 응답을 지속적으로 반복함으로써 발생하는 오버헤드가 크고, 실시간성이 떨어집니다.

롱 폴링(Long Polling) +
- **특징**: 클라이언트에서 서버로 요청을 보내고, 서버에서 새로운 데이터가 있을 때까지 요청을 보류하다가 데이터가 준비되면 응답하는 방식입니다. +
- **장점**: 실시간성이 향상되며, 폴링에 비해 HTTP 요청의 수가 감소합니다. +
- **단점**: 동시에 많은 클라이언트가 연결될 경우 서버 부하가 증가할 수 있습니다. 

WebSocket +
- **특징**: 클라이언트와 서버 간에 전이중 통신 채널을 제공하여 양방향 통신을 가능하게 하는 기술입니다. +
- **장점**: 지속적인 연결을 통해 실시간성이 매우 높고, 데이터 교환 시 오버헤드가 낮습니다. +
- **단점**: HTTP 프로토콜 위에서 작동하지만 별도의 프로토콜이 필요하며, 모든 웹 환경에서 지원되지 않을 수 있습니다.

SSE(Server-Sent Events) +
- **특징**: 서버에서 클라이언트로 단방향으로 데이터를 실시간으로 푸시하는 방식입니다. 기존 HTTP 연결을 재사용합니다. +
- **장점**: HTTP 프로토콜을 사용하므로 구현이 간단하며, 별도의 프로토콜이 필요하지 않습니다. WebSocket에 비해 더 가볍고 단순합니다. +
- **단점**: 단방향 통신만 가능하므로, 클라이언트에서 서버로의 실시간 통신이 필요한 경우에는 적합하지 않을 수 있습니다.

FCM(Firebase Cloud Messaging) +
- **특징**: 구글이 제공하는 클라우드 메시징 서비스로, 앱이나 웹에 무료로 메시지를 보낼 수 있습니다. +
- **장점**: 다양한 플랫폼에서 사용 가능하며, 대규모로 메시지를 보낼 수 있습니다. +
- **단점**: 실시간성에 제한이 있을 수 있고, 외부 서비스에 대한 의존도가 생깁니다.

- gyeongate: typescript를 도입하는 과정에서 mocking이 안되는 문제를 해결하기위해 찾아보니 mock에 여러 종류가 있어 찾아보았다. 
  * mock: 의존성이 주입 되는 시점에 모방한 객체, 모방된 객체는 동작에 대한 결과를 미리 정의할 수 있으며 몇번 호출 되었는지, 호출이 되었는지를 검증할 수 있다.
  * spy : Spy 객체는 실제 의존성의 행동을 유지하면서 호출에 대한 추가적인 정보를 기록함. Spy는 실제 객체의 래퍼(wrapper)로 동작하여 실제 로직을 실행하지만, 메서드 호출 횟수, 전달된 인자 등과 같은 추가적인 정보를 기록
  * stub : 미리 정의된 응답을 제공해주는 객체 일반적으로 테스트를 특정 방향으로 안내하기 위해 시뮬레이션되는 객체, mock과는 달리 유연하게 동작에 대한 응답을 미리 정의하는 것이 어렵다.


[[section-202404-W3]]
=== 2024년 04월 3주
- hwan: MongoDB 는 트랜잭션을 쓰려면 반드시 클러스터로 운영해야 한다. 이 때문에 마이그레이션을 해야 했다. 
+

. 데이터 덤프 및 서비스 stop
+

[source, shell]
----
db.shutdown();

mongodump --out /path/to/restore
----
+

. 클러스터로 쓸 호스트에 mongod 를 추가 설치하고 시작 옵션을 조절해 Replica set 설정
+

[source, shell]
----
mongod --replSet ${REPLICA_SET}
----
+

. Master cluster 에 replica set 을 설정
+

[source, shell]
----
rs.initiate();
rs.add({host: \"$NAME_REPL_1:$PORT_REPL_1\", priority: 0.5});
----
+

. master cluster 의 mongosh 에 접속후 dump 한 데이터를 import
+

[source, shell]
----
mongorestore /path/to/restore
----

+
. 데이터 정상 이동여부를 확인.
+

[source, shell]
----
db.collection.count()
----

- gon : `@ConditionalOnProperty` 는 조건부 빈 생성을 위한 주석Annotation이다. @ConditionalOnProperty는 주어진 속성(프로퍼티)이 특정한 값을 가질 때만 스프링 빈을 생성하거나 설정하도록 합니다.
yml이나 application.properties에 특정한 값이 있을때만 bean을 등록하게끔 할 수 있다.
문법은 다음과 같다
+

[source, kotlin]
----
@Configuration
@ConditionalOnProperty(name = ["myapp.feature.enabled"], havingValue = "true")
class MyFeatureConfiguration {

    @Bean
    fun myFeatureService(): MyFeatureService {
        return MyFeatureService()
    }

}
----


- wongue: Xcode 의 min deployment target 을 ios 업데이트 마다 재깍재깍 올려주는게 좋다. +
애플은 새로운 ios 버전 배포 이후, 가끔씩 이전 버전의 ios 지원을 걍 날려버리고, 따로 경고나 빌드시 오류를 주지 않는 경우가 종종 발생한다.

[[section-202404-W4]]
=== 2024년 04월 4주
- hwan: HTTP GET 에 Body 를 보내는 행위는 '일반적' 으로 잘못된 행위라고 인식해 왔다. 그러나 그걸 잘못되었다고 인식하는 것은 잘못되었다. HTTP 를 정의한 link:https://www.rfc-editor.org/rfc/rfc2616#section-4.3[RFC 2616] 에서는 
+

> entity-body 맥락을 정의하지 않은 요청이 message-body 를 포함한 경우 이를 되도록(SHOULD) 무시하도록 구현해야 한다
+

라는 구문이 있었다. 그러나 2014년에 HTTP 를 새로 정의한 RFC 7230 부터 RFC 7237 중 link:https://datatracker.ietf.org/doc/html/rfc7231#section-4.3[RFC 7231] 에 따르면 원래의 정의가 제거되었을 뿐 아니라 GET 요청에 대한 정의도 다음과 같이 변경되었다.
+

> GET 요청의 payload(맥락상 message-body) 는 정의된 맥락을 가지지 않는다. payload body 를 가진 GET 요청은, (서버측에서) 요청을 거절하기 위한 구현을 추가해야 할 수도 있다.
+

즉, Request body 를 포함한 GET 요청을 거부할지 말지는 서버의 몫이며 RFC 에서는 잘못되었다는 표현을 하지 않도록 변경되었다는 것이다. 10년 전에 변경된 사양을 이제서야 알게 되다니 부끄러운 한 주였다. 다만, 문서에서 이를 허용해 줬다 해서 GET 에 request body 를 담는 구현을 허용할지 말지를 가지고 싸우는 일은 피했으면 좋겠다. 예를 들어 GET 요청의 경우 복수 개의 parameter 를 표현하는 일은 대부분 번거롭다.
+

[source, shell]
----
GET https://my-site/user/profiles/ABCD,EFGH,IJKL,MNOP,QRST,UVWX

또는

GET https://my-site/user?profile=ABCD&profile=EFGH&profile=IJKL&profile=MNOP&profile=QRST&profile=UVWX
----
+

어느 쪽이던 표현이 깔끔하지 않다. 이런 경우 request body 를 포함한 GET method 를 허용하는 것도 고려한다던가 하는 유연함을 가지는 것도 좋을 것 같다.

- gyeongtae: 도메인이란 문제의 영역을 말하고 문제의 영역을 어떻게 동작하게 만들 것인지가 DDD의 본질이라고 한다. 그리고 문제의 특정 영역을 동작시키기 위한 모델이 존재할 텐데, 이것을 도메인 모델이라고 하고 도메인 모델은 곧 코드가 된다. 그리고 이 코드는 자체만으로 도메인을 설명하는 문서 역할을 하게 된다. 아예 문서가 필요없다고 할 순 없지만 도메인 지식으로부터 표현된 도메인 모델 즉, 코드로도 비즈니스가 이해될 수 있게 작성하면 따로 문서가 필요 없을것이라고 한다.

- gon: 최근에 재미있는 에러 상황을 공유 받았는데 +
os가 절전모드등 비용 감소 모드에 들어갓다가 서버가 요청을 받으니 첫번째 요청은 무조건 실패로 나는 문제였습니다. +
실패의 이유는 Jpa가 db의 트랜잭션을 가져올려다 커넥션 타임아웃으로 에러가 발생하였습니다. +
이유는 절전모드로 쓰레드기아상태가 된 상태에서 히카리cp의 housekeeper가 스레드를 할당받지못해 커넥션을 새로 맺지못했고 커넥션풀에는 만료된 커넥션만 쌓여서 그렇습니다 +
해당 에러에서 배워야할 교훈 : 우리의 서버가 항상 쓰레드를 잘 받고 돌아갈꺼라고만 생각하진 말자


[[section-202404-W4]]
=== 2024년 04월 4주

- gyeongtae:
+

[source, kotlin]
----
@GetMapping("/somePath")
fun forwardToIndex(httpServletResponse: HttpServletResponse) = "forward:/index.html'
----
+

[source, kotlin]
----
@GetMapping("/somePath")
fun redirectToIndex(httpServletResponse: HttpServletResponse) = "redirect:/index.html'
----
+

각각은 servlet에서 특정 url 요청을 index.html로 전달하는 요청이다. 이 기능을 이용해서 front-end router로 요청을 전달하려 했지만 이 둘의 차이 때문에 redirect에서는 svelte router가 동작하지 않았다. 이유는 다음과 같다. 
+
--
** forward: Servlet에서의 getServletContext() method에서 얻은 RequestDispatcher 클래스를 사용하여 받은 요청을 지정된 URL 페이지로 바꾸어 응답합니다. 이 때 client URL이 바뀌진 않습니다. 
** redirect: 302 혹은 303 상태코드 반환과 함께 client쪽에서 지정된 URL로 새롭게 요청을 보냅니다. 이 때 client URL이 바뀝니다.
--
+

왜냐하면 forward는 내부적으로 지정된 resource를 client에 영향을 미치지 않고 전달하지만 redirect는 요청 client URL에 영향을 미칩니다. forward는 내부적으로 지정된 resource를 client에 바로 반환하지만 reidrect는 302 혹은 303 상태코드를 반환하게 한 후 redirect를 client가 직접 수행하게 하여 client는 요청을 두 번 해야 원하는 resource를 전달 받을 수 있습니다.
+

이 차이로 인하여 외부 client url이 index.html로 변하면서 빈 페이지만 보였던 것입니다. 이 문제를 forward로 바꾸면 내부적으로는 index.html resource를 return 하지만 client 요청 자체는 바뀌지 않기때문에 routing url로 index.html에 요청을 할 수 있어 routing 되는데 문제가 없던 것입니다.

- gon : 읽고있는 중이라 정리는 아직 못했지만 너무 좋은 글이라 공유하여봅니다 +
https://guruma.github.io/posts/2018-11-18-Continuation-Concept/ +
cps 스타일에 대한 정석같은 아티클입니다

- hwan: IntelliJ 2022 -> 2023 업데이트 이후 Run/Debug Configurations 툴바 기능이 이상하게 바뀌어 매우 성가시다. 'Recent Configurations' 항목이 추가되며 기존에 만들어 둔 Configurations 들의 순서를 제 멋대로 바꾸는 현상이 발생하기 때문이다. 이 기능을 끌 방법을 찾아봤지만 딱히 없어 두배로 성가시다. 다만 전 세계의 다른 동료 개발자들도 이 기능을 굉장히 마음에 들지 않아 하는 것 같다. link:https://youtrack.jetbrains.com/issue/IJPL-119723/Run-widget-show-all-run-configurations-by-default[IntelliJ IDEA Bug Tracker] 에 대놓고 이 이슈가 있는 걸로 봐서는 조만간 업데이트가 있을 거라는 희망을 가져도... 되겠지?


[[section-202405-W1]]
=== 2024년 05월 1주

- gyeongtae: webflux나 webClient로 non-blocking I/O로 높은 처리량을 달성하여 다량의 파일 다운로드 시스템이나 크롤링 같은 시스템에서 자원적으로나 성능면으로나 큰 이득을 얻을 수 있지만 문제가 되는 부분은 처리량을 애플리케이션이 버틸 수 있나이다. 단적인 예로 pending Queue가 순식간에 꽉차버려 이후 요청이 버려지는 문제, 요청량 증가로 인한 CPU 부하 등이 있다. 이 경우엔 back pressure 매커니즘을 이용하여 처리량을 조절할 수 있는데 webflux에서는 다음과 같이 제공해줍니다. 
+

[source, kotlin]
----
@Test
fun `when limit rate set, then split into chunks`() {
    val limit = Flux.range(1, 25).limitRate(10)

    limit.subscribe(
        { value -> println(value) },
        { err -> err.printStackTrace() },
        { println("Finished!!") },
        { subscription -> subscription.request(15) }
    )

    StepVerifier.create(limit)
        .expectSubscription()
        .thenRequest(15)
        .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
        .expectNext(11, 12, 13, 14, 15)
        .thenRequest(10)
        .expectNext(16, 17, 18, 19, 20, 21, 22, 23, 24, 25)
        .verifyComplete()
}
----
+

또는 Message Queue를 이용한 처리량 조절도 가능하다. 이벤트는 Queue로 보내고 Queue에서 받은 이벤트를 천천히 하나 씩 처리하는 방법으로 back pressure 매커니즘을 구현할 수도 있다.
+

wongue: Flutter 프로젝트에서 공식 l10n 과 buildrunner를 같이 의존하게된다면, dart run build_runner build 를 실행할 때 오류가 발생한다. 이를 해결하기 위해서는 build_runner build 직전에 pubspec.lock 파일을 삭제하면 정상적으로 codegen 이 가능해진다. 이는 다시 dart run pub get 을 실행하기 전까지는 반복해 codegen 을 수행할 수 있다.

- gon : TransactionSynchronizationManager 란?
+

Spring 프레임워크를 사용할 때 현재 코드가 트랜잭션 내에서 실행되고 있는지 확인하는 방법은 여러 가지가 있다. 그중 대표적인것이 TransactionSynchronizationManager 클래스이다. TransactionSynchronizationManager는 스프링의 org.springframework.transaction.support 패키지에 있는 유틸리티 클래스로, 현재 스레드의 트랜잭션 상태 정보에 접근할 수 있게 해준다. 이 클래스의 isActualTransactionActive() 메소드를 사용하면 현재 코드가 트랜잭션 내에서 실행되고 있는지 여부를 확인할 수 있다.

- hwan : Optional 로 감싼 field 에 JSR-301 Validation 적용하기
+

[source, kotlin]
----
@JsonProperty("name")
val name: Optional<@Size(
    min = CustomerInflowRoute.MIN_NAME_LENGTH,
    max = CustomerInflowRoute.MAX_NAME_LENGTH
) String>?,
----

[[section-202405-W2]]
=== 2024년 05월 2주

- wongue: flutter/dart test 실행환경의 pwd 는 작성된 코드의 위치가 아닌, 해당 패키지 root 이다. +
++ dart는 js 처럼 import 'filepath' 로 JSON 파일을 가져올 수 없다.. +
따라서 mockResponse 를 Json 파일로 저장한뒤, 이를 파일 바이트스트림으로 읽어와 httpClient 의 응답으로 끼워넣는 통합 테스트를 작성하려면, +
setUp코드가 복잡해지고 구조 변경에 취약한 테스트 코드가 작성될 수 밖에 없다.
